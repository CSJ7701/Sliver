#+OPTIONS: toc:2

* Overview
:PROPERTIES:
:TOC:      :include all :depth 2
:END:

Sliver is a small Emacs package for structuring Emacs configurations into *explicit, modular load units* called /slivers/.  It provides:

- Declarative module loading
- Explicit dependency and conflict management
- Conditional loading based on machine or environment
- Lightweight visualization UI


Sliver is, at its core, a wrapper around =load-file= with added QoL functionality to reduce the mental overhead of managing a large initialization file. It is *not* a package manager.

:CONTENTS:
- [[#overview][Overview]]
- [[#concepts][Concepts]]
  - [[#loading][Loading]]
  - [[#metadata][Metadata]]
  - [[#dependencies][Dependencies]]
  - [[#conflicts][Conflicts]]
  - [[#conditional-loading][Conditional Loading]]
- [[#usage][Usage]]
  - [[#installation][Installation]]
  - [[#initial-setup][Initial setup]]
  - [[#basic-loading][Basic loading]]
  - [[#declaring-dependencies][Declaring dependencies]]
  - [[#declaring-conflicts][Declaring conflicts]]
  - [[#conditional-loading][Conditional loading]]
  - [[#profiles][Profiles]]
  - [[#ui][UI]]
- [[#reference][Reference]]
  - [[#variables][Variables]]
  - [[#functions][Functions]]
  - [[#images][Images]]
- [[#contributing][Contributing]]
- [[#roadmap][Roadmap]]
:END:


* Concepts
A /sliver/ is a single Emacs Lisp file representing one logical unit of configuration.  Slivers:

- Are loaded explicitly
- May declare dependencies on other slivers
- May declare conflicts with other slivers
- Are loaded exactly once per session

Slivers are typically stored in a dedicated directory (e.g. =~/.emacs.d/slivers/=).
Since Slivers are /just elisp files/, they can contain whatever you want. You can abstract a sliver to cover your entire "gui" setup, or encapsulate an entire language setup. Personally, I have a sliver for each major package I load, and then wrap groups of smaller packages into slivers based on common functionality. Since sliver /does not replace a package manager/, you can (and should) include your =use-package= calls (or whatever method your package manager uses) inside your slivers.

** Loading

Slivers are loaded using ~sliver-load~.  Loading is:

- Ordered (dependencies first)
- Idempotent (already-loaded slivers are skipped)
- Observable (tracked internally and via UI)


** Metadata
Sliver allows slivers to conflict with, or depend on, other slivers. This functionality is supported through the use of header metadata in each sliver file (these are just elisp comments). Metadata should look like this:

#+begin_src emacs-lisp

  ;;; name: Sliver Name
  ;;; conflicts: other_sliver
  ;;; depends: other_other_sliver
  ;;; description: This is an example

  ; 'name' is entirely unused, and only present for organizational purposes.
  ; 'description' is also unused.
  
#+end_src

** Dependencies

A sliver may declare other slivers that *must* be loaded first.  Sliver ensures:

- Dependencies load before the requesting sliver
- Cyclic dependencies are detected and rejected
- Dependencies are unidirectional (if X is dependent on Y, Y is not necessarily dependent on X)

  
Dependencies are strict: if a dependency cannot be loaded, the requesting sliver will not load. Dependencies are tracked in a metadata header inside each sliver.

** Conflicts

Slivers may declare conflicts with other slivers.  A conflict indicates that two slivers should not be loaded in the same session.

Conflict handling is configurable:

- By default, conflicts raise an error
- Users may supply a custom conflict handler
- Conflicts are symmetric (if X declares a conflict with Y, then a matching conflict is declared from Y to X)


Conflicts are tracked within a metadata header inside each sliver.

#+begin_src emacs-lisp

  ;; Example of a custom 'on-conflict' function
  (setq sliver-on-conflict-function
        (lambda (sliver conflict)
  	(message "Warning: %s conflicts with %s" sliver conflict)))

#+end_src


** Conditional Loading

Sliver supports *conditional loading*. A =sliver-load= call may be guarded by predicates such as:

- Hostname
- Operating system
- Window system
- User-defined profiles


Conditions may be combined with =:match= (default ='and=).
If conditions do not match, the sliver is silently skipped.

* Usage

** Installation

Sliver.el can be installed with Straight.el (or other git-enabled package managers), or can be installed manually.
I do not currently plan on publishing this to Melpa without significant outside interest.

#+begin_src emacs-lisp
  (straight-use-package
   '(sliver :type git :host github :repo "CSJ7701/Sliver"))
#+end_src

** Initial setup

#+begin_src emacs-lisp
  ;; Default sliver directory is "modules" within the 'user-emacs-directory'
  (setq sliver-modules-dir "~/.emacs.d/modules")
  ;; Default init file is 'init.el' within the 'user-emacs-directory'
  (setq sliver-init-file "~/.emacs.d/init.el")
#+end_src

** Basic loading

#+BEGIN_SRC emacs-lisp
(sliver-load "ui")
(sliver-load "completion")
#+END_SRC

** Declaring dependencies

#+BEGIN_SRC emacs-lisp
  ;; Declare a one-directional dependency.
  ;; The "core" sliver now depends on the "theme" sliver, but not vice versa.
  (sliver-declare-dependency "core" "theme")
#+END_SRC

The =sliver-declare-dependency= function is also interactive. It will prompt for each sliver if not provided.
Dependencies can be defined manually by editing the header inside the respective sliver file.

** Declaring conflicts

#+BEGIN_SRC emacs-lisp
  ;; Declare a two-directional conflict
  ;; The "vim" sliver now conflicts with the "evil" sliver, and vice versa.
  (sliver-declare-conflict "vim" "evil")
#+END_SRC

The =sliver-declare-conflict= function is also interactive. It will prompt for each sliver if not provided.
Conflicts can be defined manually by editing the header inside the respective sliver file.

** Conditional loading

#+BEGIN_SRC emacs-lisp

  ;; Load the 'gui' sliver if you are on a machine with hostname 'Jimmy' and using the 'x' window system
  (sliver-load "gui"
  	     :hostname "Jimmy"
  	     :window-system 'x)
#+END_SRC

By default, all predicates must match.  Logical behavior may be changed:

#+BEGIN_SRC emacs-lisp

  ;; Load the 'gui' sliver if you are on a machine with hostname 'Jimmy' OR using the 'x' window system
  (sliver-load "gui"
  	     :hostname "Jimmy"
  	     :window-system 'x
  	     :match 'or)
  
#+END_SRC

** Profiles

Profiles allow grouping conditions under a single name:

#+BEGIN_SRC emacs-lisp

  ;; Note: When setting profiles via 'sliver-machine-profiles', 'os' and 'window-system' are symbols.
  ;; This means they must be set as gnu/linux, darwin or x (without quotes).
  ;; When setting conditions directly in 'sliver-load' however, they must be quoted: 'gnu/linux, 'darwin, or 'x.
  
  (setq sliver-machine-profiles
        '(("Home-PC" . (:hostname "Jimmy" :os gnu/linux))))

  (sliver-load "desktop" :profile "Home-PC")

#+END_SRC

** UI

Sliver includes an optional UI for introspection:

#+BEGIN_SRC emacs-lisp
(M-x sliver-module-table)
#+END_SRC

The UI displays:

- All discovered slivers
- Load state
- Conflict counts
- Dependency information

  
Selecting a sliver opens a details sidebar.


* Reference

** Variables

- ~sliver-modules-dir~ :: Directory containing sliver files
- ~sliver-init-file~ :: Your init file
- ~sliver-machine-profiles~ :: Alist of machine profiles
- ~sliver-conditional-verbose~ :: Enable verbose messages for conditional loading
- ~sliver-on-conflict-function~ :: Function called when a conflict is detected
- ~sliver-after-load-hook~ :: Hook run after a sliver is loaded
  
** Functions

- ~sliver-load~ :: Load a sliver, optionally conditionally
- ~sliver-open-module~ :: Open a sliver file
- ~sliver-create-module~ :: Create a new sliver file
- ~sliver-insert-module~ :: Insert a 'sliver-load' form for a sliver
- ~sliver-init-module~ :: Insert a 'sliver-load' for for a sliver, and create the sliver file
- ~sliver-open-init~ :: Open the sliver-init-file
- ~sliver-declare-dependency~ :: Declare sliver dependencies
- ~sliver-declare-conflict~ :: Declare sliver conflicts
- ~sliver-refresh~ :: Re-scan sliver directory and metadata
- ~sliver-module-table~ :: Display the sliver UI
- ~sliver-machine-facts~ :: Display basic machine facts. Primarily for debugging or making condition definition easier.

** Images

An example of how to get started with setting up your own sliver config.

[[file:./assets/init_file.png]]



An example of what a sliver file might look like.

[[file:./assets/example_sliver.png]]



The sliver module table, with detail sidebar.

[[file:./assets/table_and_sidebar.png]]


* Contributing

Contributions are welcome.

  
* Roadmap

Planned and possible future work:

- Reverse dependency inspection in UI
- Optional unload support (best-effort... this is complex)
- Transient-based UI actions
- Expanded condition predicates
